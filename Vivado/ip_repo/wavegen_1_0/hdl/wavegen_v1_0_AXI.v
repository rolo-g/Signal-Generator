// AXI4-lite Waveform Generator IP implementation
// Rolando Rosales 1001850424
// Duy Nguyen 1001943563

// Autogenerated file implemented the AXI4-lite interface
// Many manual edits for simplification and styling
// Manual edits to add the Q interfaces and implementation

`timescale 1 ns / 1 ps

    module wavegen_v1_0_AXI #
    (
        // Width of S_AXI address bus
        parameter integer C_S_AXI_ADDR_WIDTH = 5
    )
    (
        // Ports to top level module
        /*
		input [1:0] qe0,
		input [1:0] qe1,
		*/
		output wire signed [11:0] out_a,
		output wire signed [11:0] out_b,
		output reg bram_ena_a,
		output reg bram_ena_b,
		output wire [11:0] bram_addr_a,
		output wire [11:0] bram_addr_b,
		input reg signed [15:0] bram_out_a,
		input reg signed [15:0] bram_out_b,
		input wire LDACn,
        
        // AXI clock and reset        
        input wire S_AXI_ACLK,
        input wire S_AXI_ARESETN,

        // AXI write channel
        // address:  add, protection, valid, ready
        // data:     data, byte enable strobes, valid, ready
        // response: response, valid, ready 
        input wire [C_S_AXI_ADDR_WIDTH-1:0] S_AXI_AWADDR,
        input wire [2:0] S_AXI_AWPROT,
        input wire S_AXI_AWVALID,
        output wire S_AXI_AWREADY,
        
        input wire [31:0] S_AXI_WDATA,
        input wire [3:0] S_AXI_WSTRB,
        input wire S_AXI_WVALID,
        output wire  S_AXI_WREADY,
        
        output wire [1:0] S_AXI_BRESP,
        output wire S_AXI_BVALID,
        input wire S_AXI_BREADY,
        
        // AXI read channel
        // address: add, protection, valid, ready
        // data:    data, resp, valid, ready
        input wire [C_S_AXI_ADDR_WIDTH-1:0] S_AXI_ARADDR,
        input wire [2:0] S_AXI_ARPROT,
        input wire S_AXI_ARVALID,
        output wire S_AXI_ARREADY,
        
        output wire [31:0] S_AXI_RDATA,
        output wire [1:0] S_AXI_RRESP,
        output wire S_AXI_RVALID,
        input wire S_AXI_RREADY
);

    // register map
    // ofs  fn
    //   0  control (r/w)
    //   4  period (r/w)
    //  16  position 0 (r/w)
    //  20  velocity 0 (r/w)
    //  24  position 1 (r/w)
    //  28  velocity 1 (r/w)
    
    // register numbers
    localparam integer MODE_REG         = 3'b000;
    localparam integer RUN_REG          = 3'b001;
    localparam integer FREQ_A_REG       = 3'b010;
    localparam integer FREQ_B_REG       = 3'b011;
    localparam integer OFFEST_REG       = 3'b100;
    localparam integer AMPLITUDE_REG    = 3'b101;
    localparam integer DTYCYC_REG       = 3'b110;
    localparam integer CYCLES_REG       = 3'b111;
    
    // internals    
    reg [31:0] mode;
    reg [31:0] run;
    reg [31:0] freq_a;
    reg [31:0] freq_b;
    reg [31:0] offset;
    reg [31:0] amplitude;
    reg [31:0] dtycyc;
    reg [31:0] cycles;
    
    reg LDACn_del ;
    wire LDAC_fall ;
    
    wire run_a, run_b;
    wire [2:0] mode_a, mode_b;
    wire [15:0] dc_a, dc_b;
    wire signed [15:0] ampl_a, ampl_b, offset_a, offset_b, cycles_a, cycles_b;
    assign mode_a = mode[2:0];
    assign mode_b = mode[5:3];
    assign run_a = run[0];
    assign run_b = run[1];
    assign offset_a = offset[15:0];
    assign offset_b = offset[31:16];
    assign ampl_a = amplitude[15:0];
    assign ampl_b = amplitude[31:16];
    assign dc_a = dtycyc[15:0];
    assign dc_b = dtycyc[31:16];
    assign cycles_a = cycles[15:0];
    assign cycles_b = cycles[31:16];
                
    // friendly clock, reset, and bus signals from master
    wire axi_aclk          = S_AXI_ACLK;
    wire axi_resetn        = S_AXI_ARESETN;
    wire [31:0] axi_awaddr = S_AXI_AWADDR;
    wire axi_awvalid       = S_AXI_AWVALID;
    wire axi_wvalid        = S_AXI_WVALID;
    wire [31:0] axi_wdata  = S_AXI_WDATA;
    wire [3:0] axi_wstrb   = S_AXI_WSTRB;
    wire axi_bready        = S_AXI_BREADY;
    wire [31:0] axi_araddr = S_AXI_ARADDR;
    wire axi_arvalid       = S_AXI_ARVALID;
    wire axi_rready        = S_AXI_RREADY;    
    
    // assign bus signals to master to internal reg names
    reg axi_awready;
    reg axi_wready;
    reg [1:0] axi_bresp;
    reg axi_bvalid;
    reg axi_arready;
    reg [31:0] axi_rdata;
    reg [1:0] axi_rresp;
    reg axi_rvalid;
    assign S_AXI_AWREADY = axi_awready;
    assign S_AXI_WREADY  = axi_wready;
    assign S_AXI_BRESP   = axi_bresp;
    assign S_AXI_BVALID  = axi_bvalid;
    assign S_AXI_ARREADY = axi_arready;
    assign S_AXI_RDATA   = axi_rdata;
    assign S_AXI_RRESP   = axi_rresp;
    assign S_AXI_RVALID  = axi_rvalid;
    
    // *************** DO NOT CHANGE ***************
    // Assert address ready handshake (axi_awready) 
    // - after address is valid (axi_awvalid)
    // - after data is valid (axi_wvalid)
    // - while configured to receive a write (aw_en)
    // De-assert ready (axi_awready)
    // - after write response channel ready handshake received (axi_bready)
    // - after this module sends write response channel valid (axi_bvalid) 
    wire wr_add_data_valid = axi_awvalid && axi_wvalid;
    reg aw_en;
    always_ff @ (posedge axi_aclk)
    begin
        if (axi_resetn == 1'b0)
        begin
            axi_awready <= 1'b0;
            aw_en <= 1'b1;
        end
        else
        begin
            if (wr_add_data_valid && ~axi_awready && aw_en)
            begin
                axi_awready <= 1'b1;
                aw_en <= 1'b0;
            end
            else if (axi_bready && axi_bvalid)
                begin
                    aw_en <= 1'b1;
                    axi_awready <= 1'b0;
                end
            else           
                axi_awready <= 1'b0;
        end 
    end
    // *************** DO NOT CHANGE ***************

    // *************** DO NOT CHANGE ***************
    // Capture the write address (axi_awaddr) in the first clock (~axi_awready)
    // - after write address is valid (axi_awvalid)
    // - after write data is valid (axi_wvalid)
    // - while configured to receive a write (aw_en)
    reg [C_S_AXI_ADDR_WIDTH-1:0] waddr;
    always_ff @ (posedge axi_aclk)
    begin
        if (axi_resetn == 1'b0)
            waddr <= 0;
        else if (wr_add_data_valid && ~axi_awready && aw_en)
            waddr <= axi_awaddr;
    end
    // *************** DO NOT CHANGE ***************
    
    // *************** DO NOT CHANGE ***************
    // Output write data ready handshake (axi_wready) generation for one clock
    // - after address is valid (axi_awvalid)
    // - after data is valid (axi_wvalid)
    // - while configured to receive a write (aw_en)
    always_ff @ (posedge axi_aclk)
    begin
        if (axi_resetn == 1'b0)
            axi_wready <= 1'b0;
        else
            axi_wready <= (wr_add_data_valid && ~axi_wready && aw_en);
    end       
    // *************** DO NOT CHANGE ***************

    // Write data to internal registers
    // - after address is valid (axi_awvalid)
    // - after write data is valid (axi_wvalid)
    // - after this module asserts ready for address handshake (axi_awready)
    // - after this module asserts ready for data handshake (axi_wready)
    // write correct bytes in 32-bit word based on byte enables (axi_wstrb)
    // int_clear_request write is only active for one clock
    wire wr = wr_add_data_valid && axi_awready && axi_wready;
    integer byte_index;
    always_ff @ (posedge axi_aclk)
    begin
        if (axi_resetn == 1'b0)
        begin
            mode <= 32'h0000;
            run <= 32'h0003;
            freq_a <= 32'h0000;
            freq_b <= 32'h0000;
            offset <= 32'h0000;
            amplitude <= 32'h0000;
            dtycyc <= 32'h0000;
            cycles <= 32'h0000;
        end 
        else 
        begin
            if (wr)
            begin
                case (axi_awaddr[4:2])
                    MODE_REG:
                        for ( byte_index = 0; byte_index <= 3; byte_index = byte_index+1 )
                            if ( axi_wstrb[byte_index] == 1 ) 
                            begin
                                mode[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
                            end
                    RUN_REG:
                        for ( byte_index = 0; byte_index <= 3; byte_index = byte_index+1 )
                            if ( axi_wstrb[byte_index] == 1 )
                            begin
                                run[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
                            end
                    FREQ_A_REG: 
                        for ( byte_index = 0; byte_index <= 3; byte_index = byte_index+1 )
                            if ( axi_wstrb[byte_index] == 1 )
                            begin
                                freq_a[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
                            end
                    FREQ_B_REG:
                        for ( byte_index = 0; byte_index <= 3; byte_index = byte_index+1 )
                            if ( axi_wstrb[byte_index] == 1 )
                            begin
                                freq_b[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
                            end
                    OFFEST_REG:
                        for ( byte_index = 0; byte_index <= 3; byte_index = byte_index+1 )
                            if ( axi_wstrb[byte_index] == 1 )
                            begin
                                offset[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
                            end
                    AMPLITUDE_REG:
                        for ( byte_index = 0; byte_index <= 3; byte_index = byte_index+1 )
                            if ( axi_wstrb[byte_index] == 1 )
                            begin
                                amplitude[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
                            end
                    DTYCYC_REG:
                        for ( byte_index = 0; byte_index <= 3; byte_index = byte_index+1 )
                            if ( axi_wstrb[byte_index] == 1 )
                            begin
                                dtycyc[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
                            end          
                    CYCLES_REG:
                        for ( byte_index = 0; byte_index <= 3; byte_index = byte_index+1 )
                            if ( axi_wstrb[byte_index] == 1 )
                            begin
                                cycles[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
                            end          
                endcase
            end
        end
    end    

    // *************** DO NOT CHANGE ***************
    // Send write response (axi_bvalid, axi_bresp)
    // - after address is valid (axi_awvalid)
    // - after write data is valid (axi_wvalid)
    // - after this module asserts ready for address handshake (axi_awready)
    // - after this module asserts ready for data handshake (axi_wready)
    // Clear write response valid (axi_bvalid) after one clock
    wire wr_add_data_ready = axi_awready && axi_wready;
    always_ff @ (posedge axi_aclk)
    begin
        if (axi_resetn == 1'b0)
        begin
            axi_bvalid  <= 0;
            axi_bresp   <= 2'b0;
        end 
        else
        begin    
            if (wr_add_data_valid && wr_add_data_ready && ~axi_bvalid)
            begin
                axi_bvalid <= 1'b1;
                axi_bresp  <= 2'b0;
            end
            else if (S_AXI_BREADY && axi_bvalid) 
                axi_bvalid <= 1'b0; 
        end
    end   
    // *************** DO NOT CHANGE ***************

    // *************** DO NOT CHANGE ***************
    // In the first clock (~axi_arready) that the read address is valid
    // - capture the address (axi_araddr)
    // - output ready (axi_arready) for one clock
    reg [C_S_AXI_ADDR_WIDTH-1:0] raddr;
    always_ff @ (posedge axi_aclk)
    begin
        if (axi_resetn == 1'b0)
        begin
            axi_arready <= 1'b0;
            raddr <= 32'b0;
        end 
        else
        begin    
            // if valid, pulse ready (axi_rready) for one clock and save address
            if (axi_arvalid && ~axi_arready)
            begin
                axi_arready <= 1'b1;
                raddr  <= axi_araddr;
            end
            else
                axi_arready <= 1'b0;
        end 
    end       
    // *************** DO NOT CHANGE ***************
        
    // Update register read data
    // - after this module receives a valid address (axi_arvalid)
    // - after this module asserts ready for address handshake (axi_arready)
    // - before the module asserts the data is valid (~axi_rvalid)
    //   (don't change the data while asserting read data is valid)    
    wire rd = axi_arvalid && axi_arready && ~axi_rvalid;
    always_ff @ (posedge axi_aclk)
    begin
        if (axi_resetn == 1'b0)
        begin
            axi_rdata <= 32'b0;
        end 
        else
        begin    
            if (rd)
            begin
		        // Address decoding for reading registers
                case (raddr[4:2])
                    MODE_REG: 
                        axi_rdata <= mode;
                    RUN_REG:
                        axi_rdata <= run;
                    FREQ_A_REG:
                        axi_rdata <= freq_a;
                    FREQ_B_REG:
                        axi_rdata <= freq_b;
                    OFFEST_REG:
                        axi_rdata <= offset;
                    AMPLITUDE_REG:
                        axi_rdata <= amplitude;
                    DTYCYC_REG:
                        axi_rdata <= dtycyc;
                    CYCLES_REG:
                        axi_rdata <= cycles;
                    default:
                        axi_rdata <= 32'b0;
                endcase
            end   
        end
    end    

    // *************** DO NOT CHANGE ***************
    // Assert data is valid for reading (axi_rvalid)
    // Assert data is valid for reading (axi_rvalid)
    // - after address is valid (axi_arvalid)
    // - after this module asserts ready for address handshake (axi_arready)
    // De-assert data valid (axi_rvalid) 
    // - after master ready handshake is received (axi_rready)
    always_ff @ (posedge axi_aclk)
    begin
        if (axi_resetn == 1'b0)
            axi_rvalid <= 1'b0;
        else
        begin
            if (axi_arvalid && axi_arready && ~axi_rvalid)
            begin
                axi_rvalid <= 1'b1;
                axi_rresp <= 2'b0;
            end   
            else if (axi_rvalid && axi_rready)
                axi_rvalid <= 1'b0;
        end
    end
    // *************** DO NOT CHANGE ***************    

    // Signal generation code begins here
    
    // Registers/wires for signal generation
    reg signed [19:0] outcalc_a;
    reg signed [19:0] outcalc_b;
    reg [31:0] accum_a;
    reg [31:0] accum_b;
    reg signed [14:0] sq_level_a;
    reg signed [14:0] sq_level_b;
    wire signed [10:0] s_accum_top_a;
    wire signed [10:0] s_accum_top_b;
    wire [10:0] sq_accum_top_a;
    wire [10:0] sq_accum_top_b;
    
    reg [63:0] accum_offset_a;
    reg [63:0] accum_offset_b;
    
    // Phase accumulator values
    int N_a;
    int N_b;
    int dir_a;
    int dir_b;
    
    initial
    begin
        dir_a = 1;
        dir_b = 1;
        sq_level_a = 10000;
        sq_level_b = 10000;
    end
    
    // easy to read names for phase accumulator
    assign s_accum_top_a = accum_a [31:21];
    assign s_accum_top_b = accum_b [31:21];
    assign bram_addr_a = accum_a [31:20];
    assign bram_addr_b = accum_b [31:20];
    assign sq_accum_top_a = accum_a [31:21];
    assign sq_accum_top_b = accum_b [31:21];
    
    // assign output ports which go to top-level to bottom 11 bits of calculation reg
    assign out_a = outcalc_a [11:0];
    assign out_b = outcalc_b [11:0];
    
    always_ff @ (posedge axi_aclk)
    begin
        LDACn_del <=  LDACn;
    end 
    
    assign  LDAC_fall = ~LDACn & LDACn_del;
    
    always_ff @ (posedge axi_aclk)
    begin
        if(LDAC_fall)
        begin
            accum_offset_a <= (freq_a << 32)/32'd100000;
            accum_offset_b <= (freq_b << 32)/32'd100000;
        end 
    end 
    
    
    always_ff @ (posedge axi_aclk)
    begin
        if(LDAC_fall)
        begin
            accum_a <= accum_a + accum_offset_a[31:0] * dir_a;
            accum_b <= accum_b + accum_offset_b[31:0] * dir_b;
        end 
    end 
    
    always @ (posedge axi_aclk)
    begin
        if (run_a)
        begin
            if (cycles_a == 0) // to be changed once cycles implemented
            begin
                case (mode_a)
                    3'b000:     // DC
                    begin
                        bram_ena_a <= 0;
                        
                        outcalc_a <= (offset_a * 8) >> 7;
                    end
                    3'b001:     // Sine
                    begin
                        bram_ena_a <= 1;
                        dir_a <= 1;
                        
                        outcalc_a <= ((bram_out_a * ampl_a) + (offset_a * 8)) >> 7;
                    end
                    3'b010:     // Sawtooth
                    begin
                        bram_ena_a <= 0;
                        dir_a <= 1;
                       
                        outcalc_a <= (((s_accum_top_a * 10) * ampl_a) + (offset_a * 8)) >> 7;
                    end
                    3'b011:     // Triangle
                    begin
                        bram_ena_a <= 0;
                        
                        if (s_accum_top_a >= 1021)                        
                        begin
                            dir_a <= -2;
                        end
                        else if (s_accum_top_a <= -1021)
                        begin
                            dir_a <= 2;
                        end
                        
                        outcalc_a <= (((s_accum_top_a * 10) * ampl_a) + (offset_a * 8)) >> 7;
                    end
                    3'b100:     // Square wave
                    begin
                        bram_ena_a <= 0;
                        dir_a <= 1;
                        
                        if (sq_accum_top_a >= dc_a)
                        begin
                            sq_level_a <= -10000;
                        end          
                        if (sq_accum_top_a <= dc_a)
                        begin
                            sq_level_a <= 10000;
                        end
                        
                        outcalc_a <= ((sq_level_a * ampl_a) + (offset_a * 8)) >> 7;
                    end
                endcase
            end
            else    // if all cycles complete, just output 0
            begin
                outcalc_a <= 0;
                // accum_a <= 0;
            end
        end
        else outcalc_a <= 12'h000;  // if run bit not set, just output 0        
     end
     
     always @ (posedge axi_aclk)
     begin 
        if (run_b)
        begin
            if (cycles_b == 0) // to be changed once cycles implemented
            begin
                case (mode_b)
                    3'b000:     // DC
                    begin
                        bram_ena_b <= 0;
                        
                        outcalc_b <= (offset_b * 8) >> 7;
                    end
                    3'b001:     // Sine
                    begin
                        bram_ena_b <= 1;
                        dir_b <= 1;
                        
                        outcalc_b <= ((bram_out_b * ampl_b) + (offset_b * 8)) >> 7;
                    end
                    3'b010:     // Sawtooth
                    begin
                        bram_ena_b <= 0;
                        dir_b <= 1;
                       
                        outcalc_b <= (((s_accum_top_b * 10) * ampl_b) + (offset_b * 8)) >> 7;
                    end
                    3'b011:     // Triangle
                    begin
                        bram_ena_b <= 0;
                        
                        if (s_accum_top_b >= 1021)                        
                        begin
                            dir_b <= -2;
                        end
                        else if (s_accum_top_b <= -1021)
                        begin
                            dir_b <= 2;
                        end
                        
                        outcalc_b <= (((s_accum_top_b * 10) * ampl_b) + (offset_b * 8)) >> 7;
                    end
                    3'b100:     // Square wave
                    begin
                        bram_ena_b <= 0;
                        dir_b <= 1;
                        
                        if (sq_accum_top_b >= dc_b)
                        begin
                            sq_level_b <= -10000;
                        end          
                        if (sq_accum_top_b <= dc_b)
                        begin
                            sq_level_b <= 10000;
                        end
                        
                        outcalc_b <= ((sq_level_b * ampl_b) + (offset_b * 8)) >> 7;
                    end
                endcase
            end
            else    // if all cycles complete, just output 0
            begin
                outcalc_b <= 0;
                // accum_b <= 0;
            end
        end
        else outcalc_b <= 12'h000;  // if run bit not set, just output 0
    end
    
endmodule